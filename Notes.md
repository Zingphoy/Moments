# 开发感想

这篇东西是这个web系统demo编码给我留下来的收获，实际上我觉得不太能叫得上开发这个词（有点不配😂），因为很多东西都不是自己思考出来而是参考别人的做法。这一次编码经历更像是开启了一扇大门，给我更大的收获不是开发时怎么做，而是什么不要做，同时也给了我一些命题让我去需求答案。为什么会有最佳实践这种东西，事情真的会有最完美的解决办法吗？我觉得不是，问题和解法是需要case
by case的，但总的来说还是会有一些朴普适的原则，遵循这些原则来开发，可以保证开发出来的质量下限。

以上就是开篇的废话，我们进入正题吧。

## 用到的组件

- mongo-client
- 配置文件
- 参数验证validator

## 关于分层的命名规范

没什么特别的头绪，也不知道最佳实践是怎么样子的，因为项目本身是参考俩github上的gin演示项目（都是国人开发的，逻辑比较好理解），就直接照搬别人的命名方式。

model层的方法名是能看出来具体要干嘛的，比如`GetArticleDetailByAid(aid int64) (*Aticle, error)`
。service层则相对语义化一些，只能看出来是某个动作，但是无法直观知道实现，比如`DetialAticle()`
。最后还要留意不同模块间的命名规范要对齐，所以我自己在编码的时候，先写好第一个模块比较完整的功能（挑了一个简单的模块），然后其他模块照着这个模块的感觉来"抄"。


## 关于目录模块

使用传统MVC思想，主要文件夹有3个，分别是：model、service、router。没什么好说的，本身需求逻辑就很简单，不需要过度复杂的划分。

后来发现model层和service层的代码文件十分多看着很难受（包括test文件），也是因为每个模块在每层就只有一个文件，MVC的横向划分看着就很简陋，于是尝试MVC的纵向划分，每个模块放在一个文件夹中，尝试来提高模块划分的可读性。

按照MVC纵向划分后很快又发现了另一个问题，因为模块之间是需要互相调用的，在MVC横向分层的时候，model之间的调用不需要import，调用其他层就需要import，会有个明显的约束是不同模块之间的较差调用在同一层内收敛，比如service层的模块A只会调用service层的模块B，而不会直接调用model层的模块B。但是当做了纵向划分后，这个潜在约定便不存在了，跨模块的调用都需要import，而人在写代码时就需要留意是否出现不规范的跨层调用，调用链是否清晰是一个项目可维护性好坏的体现。


## 关于注释

最开始的打算是使用全英文注释，后来写着写着，这逻辑都简单成这样了，函数名也很直接，还强行写注释，是不是减低了可读性显得很啰嗦（尤其是英文写得又不好）……

---

## 关于单元测试

原本打算把单测拉满，尽可能多地达到高覆盖率，后面觉得不太可行，一方面是心有余而力不足，很多逻辑太简单完全没单测的必要，另一方面是单测要写得多也比较费时，我选择尽快结束这个demo，把时间投入到下一个demo中去。

### 最开始的单测

1. 造数据，给数据库插入数据
2. 测试逻辑，验证结果
3. 清理数据库数据

优点：几乎没有发现优点

缺点：代码繁冗，单测代码比被测代码还要长，清数据要考虑单测的逻辑，有些测试时的异常退出会导致没有清测试数据。维护成本特别高，简单重构一下代码，单测也要跟着改。

### gomock的应用

单测插入和清理数据这么麻烦，为什么不尝试用mock来mock掉数据库层的返回？

基于这个出发点了解了一下gomock，发现原代码根本没有interface层的抽象，完全没法使用mock，最终对model层做了一通修改后再尝试套用gomock，结果是写不出来……
强行的抽象在简单的业务逻辑中显得格格不入，极度不直观，甚至连我自己都无法理解这样的抽象，最终放弃使用mock，再次改回常规单测逻辑。

### 最终的单测

这一次改回去，我才发现原来testify包中有suite这个东西，之前一直费解为什么go的单测不支持常规的setup teardown这么奇怪，官方testing包只有一个`TestMain()`
的hook很不好用。最终发现不是没有而是我笨没看到……
使用suite重新组织单测，关联的单测逻辑放在同一个suite中，一下子清晰了很多。不过这里引出了一个问题，testify对于单测函数的执行不是按照函数的实现顺序，而是按照Test函数名在字母表中的顺序，举个例子：

```go
package main

import "testing"
import "github.com/stretchr/testify/suite"

type MySuite struct {
	suite.Suite
}

func (s *MySuite) TestB() {
	// TBD
}

func (s *MySuite) TestA() {
	// TBD
}

func TestMySuite(t *testing.T) {
	suite.Run(t, new(MySuite))
}

// 最终单测执行的顺序是先执行`TestA()`，再执行`TestB()`。不是按照实现顺序，而是按照函数名称在字母表的顺序。
```

关于单测函数执行顺序的问题，详见[issue链接](https://github.com/stretchr/testify/issues/194) 。

另外，需要好好使用suite提供的hook函数，几个关键的hook如下：

1. `SetupSuite()`：整个suite开始执行前运行1次
2. `SetupTest()`：每个Test函数开始执行前都运行
3. `BeforeTest(string,string)`：每个Test函数开始执行前都运行（在SetUpTest之后），而且能拿到suite和单测函数的名字
4. `AfterTest(string,string)`：每个Test函数执行结束时都运行（在TearDownTest之前），而且能拿到suite和单测函数的名字
5. `TearDownTest()`：每个Test函数执行结束时都运行
6. `TearDownSuite()`：整个suite结束时运行1次

一开始没意识到`BeforeTest`和`AfterTest`
的作用，在测试新增文章和删除文章的时候，因为本身suite中的单测函数运行是不保证顺序的，所以我额外独立了另一个suite专门放add和delete这两个互相依赖的逻辑，后来感觉应该在`BeforeTest`和`AfterTest`
中做判断会更好一些，于是最终又合并成一个suite，利用`BeforeTest`和`AfterTest`来使得add和delete的单测状态互相传达。

### 单测的感想

1. 简单的逻辑，不需要刻意去单测，只要保证错误能暴露即可
2. 单测不必刻意追求覆盖率，应该测试的是业务功能，而不是测试代码实现
3. 有完备的单测，是改代码是的安心药，但是重构代码就要调整单侧，以为着代码抽象度太低，耦合严重

参考资料：

1. [为什么要进行单元测试，以及如何让它为你工作](https://learnku.com/go/t/34095)
2. [Go 编程实战：如何组织代码、编写测试？](https://www.infoq.cn/article/4tawp8ynycvd4t046egd)
3. [Mock七宗罪](https://gitbook.cn/books/58fa1af500a2684bf77511bc/index.html)

---

## 关于错误处理

一开始我的错误处理方式就是无脑的`return err`
，弊端简直不能更明显，底层的错误被一层层地传到response层，中间基本丢掉全部上下文信息，到了response时已经不知道这个error是来自哪里的，没法向调用方解释这个error是什么。

go本身对错误处理就有特别的设计含义，go官方倡导的原则是：`Don't just check errors, handle them gracefully`
。error本身也不应该被重复处理，所以比较好的方式是把error集中在某一层去处理并记录日志。我对error做一个简单的封装，加上特定错误码来让上层识别错误类型做对应处理，这里需要提前梳理一波潜在的业务错误情况，做好错误码规划，这样看起来整洁一些，但可能还不是一个很好的解决办法，因为没对response做更多限制，还是存在不小心违背约定的错误返回。

上面说到的是通用error的处理，在实际编码中还有另一个问题困扰我，对于业务逻辑上的error应该要怎么处理？

举个实际例子：查询接口，查询为空时，在业务场景中这个逻辑是定性为正常还是异常呢？这个问题用实际代码来表达可能更好，如下：

```go
package main

type people struct {
	name string
	age  int
}

func QueryPerson(name string) (age int, err error) {
	// 正常查询出结果
	return 18, nil
	
	// 查询无结果，此时应该如何返回？是要返回error来告诉下游，还是返回error为nil但是age为0等异常结果？
}

```


首先可以明确的是，这种情况返回error置nil，调用者还需要检查一遍返回的age值是否合法，从而知道返回的结果是正常还是异常。 不过我自己的实现中倾向让error返回承担更多责任，这样可以让主干逻辑的流程更为清晰，当然这取决于类似查找结果为空在不同业务场景上是怎么看待的，我见过的系统在查询为空时一般不会以error的形式返回。我的实现是违背常识的，我还是更倾向于常规的实现，查询为空不应该返回error，但是懒得改了。

go官方倡导的：`Errors are just values`


参考资料：

1. [Go语言中的错误处理](https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/)
2. [Go错误处理最佳实践](https://lailin.xyz/post/go-training-03.html)
3. [如何优雅的 Golang 错误处理](https://learnku.com/go/t/33210)
4. [Go编程模式：错误处理](https://coolshell.cn/articles/21140.html)

## 关于日志规范

1. 区分请求唯一标识
2. 日志格式统一
3. 尽量只打有用的日志

第一点：区分请求唯一标识。

最开始本机打日志的时候是没带请求id的，因为一直是单请求跑没有留意到这事。但实际上一个能上线的实际系统，日志不可能是这样打的，因为你没法区分这个日志是哪个请求留下来的，不同请求之间的日志需要能区分出来，这也是我这种菜鸡首次意识到的事情，所以每个请求需要带上它的请求id，打日志的时候通过全局唯一（极高概率唯一就可以）id来过滤出某个请求的全部日志，再排查问题

第二点：日志格式统一。

在个人调试的时候喜欢乱打日志，格式不统一。日志的本质就是希望留下足够排查问题的信息，但是要强调信息够用就好不要一味添加信息引入噪音。最简单的，一行日志打出来应该是什么样子。再细一点的，不同级别的日志应该怎么定义。最后的，思考假如让一个不熟悉系统的人来看日志，他能否获取到有用的信息，底层日志应该如何包装成有业务含义的日志等。

第三点：尽量只打有用的日志。

有时把整个结构体或变量print出来，有时if逻辑里面和外面都打一条日志看逻辑到底走到哪里，有时同一份error日志在上游打了一次，下游收到error返回值再打一次。这种日志的打法可能是我这种菜鸡最常见的操作方式，总结来说就是能用蛮力就用蛮力，坚决不动脑😂，最终的结果就是留下了很多无用日志，如果不及时清理，时间一长堆积起来会明显降低阅读理解日志的效率。

在日志的实现上踩了个坑，一开始我是照着别人的项目，抄了一个log模块下来自己用，后来希望在每个log日志前加一个request-id，这个request-id是通过middleware写在request
header中。忽然发现这个需求没法做，如果要做，就必须层层透传context，否则request
header没地方获取，为了打个日志就透传context，这无疑是很丑陋的。了解gin自带的log功能，发现只能当成一个middleware来用，意味着只能针对流量入口出口打日志，没法深入到业务逻辑中自定义打日志，卡关了……
再尝试谷歌一下，好像真的只能通过透传context实现，没有其他办法，也是我只能硬着头皮到处传context，不过控制在controller和service层，model层就不再透传了，model层不打日志，通过error的形式返回上下文，让error本身承载更多的信息，问题集中在上一层处理，这也勉强算是业务逻辑更加内聚在service层的办法。

参考资料：

1. [日志规范整理](http://blog.lastww.com/2019/01/30/log-practice)
2. [When to use different log levels - stack overflow](https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels)
3. [最佳日志实践](https://zhuanlan.zhihu.com/p/27363484)

## 关于解耦

解耦原本是



模块如果能满足高内聚低耦合，应该不存在这些问题，但是如果发现了这些问题确实存在，代表模块直接存在过多耦合，逻辑不能闭合在模块内部

很典型的例子，错误传递和打日志

## 关于RocketMQ

这里不做太详细的介绍，因为网上已经有不少原理解释文章了，对于我来说，因为从来没用过MQ，所以看资料对我的作用十分有限，还是拿一个具体的MQ使用过，在使用的过程中不断解决疑问来得更有效。

## 后记

其实整个demo的编码周期十分漫长，平时就很晚下班，也就是拿点午休和晚上下班后的业余时间捣鼓捣鼓，周末没事情也写着乐一乐。从10月底想法出来到简单的接口设计到功能细节的确定，本身时间很短，就是几个小时，因为是自己第一次稍稍完整一点的经历，本身自驱力也十分有限（典型的间歇性踌躇满志，持续性混吃等死），所以这么简单的demo搞了小半年o(
╥﹏╥)o。有时不得不感慨，自己跟大佬的区别，至少在自律自驱以及动手能力上已经被拉了九十九条街了。

不过也不必灰心，还是赶紧鞭策自己现在就开始种那颗十年前没种的树吧。

也是因为自己想快点结束这个demo，能开始下一段的学习，所以很多地方实现地非常粗糙，性能零考虑、单测难维护、错误处理杂乱、代码复用差等数不胜数很扎眼的问题，不过依然希望这份demo能帮到正在入门的小白。

从开始到结束，每个模块的代码行数都很少，但实际上反复修改了非常多次，也得益于代码量少和逻辑简单，我能够慢慢地把代码往更好的方向去调整，这不得不让我想到，如果一个系统足够庞大，一个人要熟悉整个系统的一切是不可能的，大范围的重构也是从一砖一瓦开始，而低内聚高耦合的代码真的会折腾死人。我也看过公司内部项目，有些很简单的需求要加，但是要同时改动好几个零散的文件，这里插几行那里改一下，试问这样的项目给到我手上，我真的不敢保证我的任何代码变更不会出现问题。所以，写代码要设计先行。

重构不要懒惰，经常在写完一些代码后很快就出现更好的想法，这个时候要保证好的写法可以第一时间被完整记录下来，第二个就是立马合理重构，越往后拖，局部重构的影响范围就会随着代码增多越发扩散

go的receiver到底要怎么用？它本身是否适合传递数据？还是说让函数参数或返回值作为传递数据结果的渠道，目前我没有思绪，